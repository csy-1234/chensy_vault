---
date: "25050818"
docxmysql主从架构.docx: 数据库主从架构.docx
---

# 数据库主从架构
## 笔记

==MySQL replication概述==

==MySQL复制类型==

==MySQL复制原理==

==部署mysql主从异步复制==

==部署mysql主从半同步==

==思考问题==
## 补充

==mysql是==
**是**
	一种数据同步技术

**目的是**
	读写分离--高可用、高性能、高扩展、

MySQL软件下载？

https://dev.mysql.com/downloads/mysql/

==下载选择原则==

|版本类型|使用建议|适用场景|
|---|---|---|
|**GA（稳定版）**|优先选择|生产环境、开发新项目|
|**Archives（历史版本）**|仅在特殊情况下|老系统兼容、回滚、测试旧问题|

## 实验

目的：搭建mysql一主一从架构（包管理器安装）   
原理： 
	从库会通过 I/O 线程 读取主库的 binlog； 
	SQL 线程 在本地重放这些 binlog，从而保持和主库一致
机器：两台vm,均2G
软件：8.0.42
==效果：主从复制成功，可以同步==
局限：原生主从复制(CHANGE MASTER TO)本身 没有故障转移机制。自动故障转移，就需要额外的工具/架构
### 异步
异步复制实验
![[a52db1256f65b0ccc422682d8149390.jpg]]

![[98fb571b3e647fd1da63a4fc60cefa5.jpg]]

```
--创建从库用户更建议的做法：
只授予 REPLICATION SLAVE 权限，更安全，更符合生产环境规范
#CREATE USER 'slave_user'@'%' IDENTIFIED BY 'Slave@1234';
#GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'%';
#FLUSH PRIVILEGES;

#flush privileges;	#如果是grant和revoke，可用可不用该条命令

--show master status;	#查看看主库当前主库的二进制日志文件（binlog）和位置;

--默认目录：MySQL 的 数据目录（datadir），通常是：/var/lib/mysql/

--配置文件
主库必有：
server-id         #服务器唯一id
log_bin=mysql-bin  #开启二进制文件，指定文件名
从库必有：
server-id         #服务器唯一id
relay_log = relay-log-bin  # 启用中继日志，指定文件名

```

![[d63d52c5b8b4f380613b367cc5f5c0a.jpg]]


总结
>主从均：rpm安装myslq
>主库从库：配置serverid和开启binlog和relaylog+重启mysqld
>主库：创建复制用户+从库：配置主库source


关键配置
![[Pasted image 20251010110816.png]]
![[Pasted image 20251010110926.png]]
![[Pasted image 20251010110954.png]]
### 半同步

![[7427d75c8d4f8f2c41fdd93bb3f3d45.jpg]]
>主从库：修改配置文件+重启+安装启用插件；
>从库：配置source源

| 命令                      | 类型       | 意义               |     |
| ----------------------- | -------- | ---------------- | --- |
| `SHOW GLOBAL VARIABLES` | **配置变量** | 表示数据库的配置项（静态或动态） |     |
| `SHOW GLOBAL STATUS`    | **状态变量** | 表示数据库的运行统计（动态）   |     |
## 问题


==主从复制和MySQL主从复制是一个东西吗？==

 1.**主从复制（Master-Slave Replication）**
- **定义**：一种 **数据同步模型或架构模式**。
- **核心思想**：
    - **主节点（Master）**：负责写操作，记录数据变更。
    - **从节点（Slave）**：复制主节点的数据变更，用于读取或备份。
    - 可实现读写分离、容灾、备份和高可用。 
- **特点**：
    - 模型本身 **不依赖特定软件**，只是描述数据流和同步关系。
    - 不管是 MySQL、Redis、MongoDB 还是其他数据库，都可以实现主从复制。
 2.**具体实现软件**

- **MySQL**：**主从复制/组复制**（Group Replication）
    
- **Redis：主从复制**（Master-Slave）
    
- **MongoDB：副本集**（Replica Set）
    
- **PostgreSQL：流复制**（Streaming Replication）
    
- **消息队列**（如 Kafka）也有 Leader-Follower 模式，属于主从模式的一种
3.总结
所以 说主从复制 并不等于 MySQL，MySQL 只是最常见的实现之一，而且“主从复制”在不同软件里确实有不同的叫法，但本质都是 **“主节点写入，从节点同步数据”** 这种机制

==高可用和主从复制的关系的关系？==

高可用（High Availability，HA）：**最大化服务可用时间**，保证业务连续性

replication目的：
	读写分离（主写从读）
	高可用（主库挂了可以切换到从库）
但是
主从复制 ≠ 高可用
不是等价关系，而是包含关系

高可用（High Aviliability）包括两部分：
1.主从复制（数据层保障）
	数据冗余（挂了**可以切换从库**）
2.**故障检测+转移**（调度层保障）
	自动发现 master 宕机
	自动挑选一个合适的从库，提升为新主；
    通知客户端/中间件，路由到新主库；
     其他从库改为复制新主库
 

**故障检测 + 转移必须建立在主从复制之上**

- 原因：如果没有从库，故障切换就无从谈起
- 主从复制提供了“备份数据源”和“候选主库”，调度层才能选出新的主库

各种HA：
- **数据库 HA**：MySQL 主从 + MHA 或 Group Replication
- **缓存 HA**：Redis 主从 + 哨兵
- **Web HA**：负载均衡 + 多台 Web 服务器

==MySQL的故障检测和故障转移怎么实现**？==

> 主从复制（无 HA）  
> 依赖外部工具 (MHA/Orchestrator) 或官方 Group Replication 才能 HA

==mysql主从通信和客户端通信的区别？==

| 对比点  | 主从之间                              | 客户端与 MySQL             |
| ---- | --------------------------------- | ---------------------- |
| 连接角色 | 从库 = 客户端，主库 = 服务端                 | 应用 = 客户端，MySQL = 服务端   |
| 使用协议 | MySQL 内部协议（binlog dump 协议，基于 TCP） | MySQL Client/Server 协议 |
| 数据内容 | binlog 事件（数据变化日志）                 | SQL 请求 + 查询结果          |
| 目的   | 保证主从数据一致性                         | 提供业务数据查询与修改            |
| 典型线程 | 主库：dump 线程；从库：I/O 线程、SQL 线程       | 客户端连接线程（一个连接一个线程）      |

- MySQL **只有一个服务端口**（3306），但它是 **多协议多命令的复用协议**。
    
- 就像 HTTP 服务器一样，一个 80 端口可以返回网页，也可以返回 JSON、图片，只是内容不同。
    
- 主从通信看起来像“客户端-服务端通信”，但内容换成了 **binlog event**。

总结：

- **MySQL 所有对外通信本质都是 C/S 架构**。

	- 应用程序是普通客户端；
	- 从库是“复制客户端”；
    
	- 服务器始终是 `mysqld`。

==主从复制和分布式数据库的关系？==

 1.单纯的主从复制 ≠ 分布式数据库
- **主从复制**只是 **数据同步机制**：
    - 主节点写入
    - 从节点同步数据
    - 提供高可用、读扩展
- **没有分片**，所以**数据仍在同一逻辑数据库里**
2.单纯的分布式数据库≠主从复制
- **特征**：数据 **水平分片（Sharding）** + 多副本
    - 数据分散到多个节点（分片）
    - 每个分片可以有副本（主从复制/副本集）
- **可选功能**：主从复制/副本集


3.也就是说没有必要关系，只是附加功能，但是：
	**分片是核心，主从复制和负载均衡是增强功能，但生产环境几乎都会加上**

4.主从复制和分片是两个独立维度:
	主从复制 → 高可用 + 读扩展
	主从复制：
	分片：
		**分片 = 数据逻辑/物理切分**，不一定是表
		**哈希 + 槽位**是主流机制，保证均匀分布和高效扩容
		 **路由机制**决定数据能找到对应分片节点
		 **单纯分仓库不分片**不能解决单节点并发瓶颈问题；
		 **目的**：解决单节点容量和性能瓶颈实现横向扩展，支持更多数据和更高并发；实现双向减压
		 切分（**Sharding**）方式：哈希分片（slot槽位）、范围分片、列表分片
		 **路由机制**：Key（查询数据的某个固定结构，一般是主键或key） → 分片 → 节点
		 高可用：每个分片可以有副本（主从复制 / Replica Set）
		 针对mysql的分片实质是：分表、分库
		 针对NoSQL的分片实质是：数据实体
		 


==水平扩展和垂直扩展是什么？==
- **垂直扩展（Vertical Scaling / Scale Up）**：提升单台机器的性能（CPU、内存、硬盘）
    
- **水平扩展**：增加更多机器，实现横向扩展，通过增加更多节点（服务器）来扩展系统的处理能力或存储容量，而不是提升单台机器的性能

==主从复制还需要另外备份吗？==

- **从库不是备份**
    
    - 主库误操作或故障会同步到从库，从库数据也会受影响；
    - 从库无法回溯，只能跟随主库变化。
        
- **自动备份的作用**
    - 提供最后的保险，即使所有节点挂掉也能恢复；
    - 支持精确历史回溯；
    - 满足合规/审计要求。
    - 真正的备份 = 主库的全量备份（数据快照） + Binlog 增量备份
        
- **核心理解**
    - **从库**：保证高可用、读写分离、负载均衡；
    - **备份**：保证可恢复性。
    - 

---

 ==主从复制的作用是什么？==

1. **高可用（HA）**
    
    - 主库挂了，可以快速切换到从库（结合 MHA、Keepalived、Orchestrator 等工具）。
        
    - 保证业务连续性。
        
2. **读写分离**
    
    - 主库专门负责写操作，从库负责读操作。
        
    - 提高并发处理能力。
        
3. **扩展性**
    
    - 可以挂多个从库，做报表、数据分析，而不影响主库性能。

==主库对于客户端的sql请求的处理流程？==
有以下几个阶段：
1.客户端事务请求

BEGIN;
UPDATE account SET balance = balance - 100 WHERE id=1;
COMMIT;

2.接收+parse

MySQL 的 SQL 层解析 SQL 语句。
优化器生成执行计划。
执行器调用存储引擎（如 InnoDB）来真正修改数据

3.写入 InnoDB redo log

储引擎执行更新操作时，会先写 **redo log**（物理日志，用于崩溃恢复）。redo log 进入 **prepare** 状态，但还未提交

4.写入 binary log（逻辑日志）

5.两阶段提交（Two Phase Commit）

binary log提交之后，redo log提交（状态变为commit）；此时事务固化，崩溃可恢复

6.等待从库同步

主库检测到固化后推送binlog给slave
slave写入relay log，执行relay log，返回ack
异步复制此步骤在client commit ok之后

7.发送commit ok （ACK）给client

==衡量一个系统整体性能或状态时常说的几个 “高” 是哪些？==

| 名称       | 英文                         | 含义        |
| :------- | :------------------------- | :-------- |
| **高可用**  | **High Availability (HA)** | 故障容忍      |
| **高性能**  | **High Performance (HP)**  | 快速响应、高吞吐量 |
| **高并发**  | **High Concurrency (HC)**  | 同时处理大量请求的 |
| **高可靠**  | **High Reliability**       | 不丢失、不错误   |
| **高可扩展** | **High Scalability**       | 灵活扩容      |
HA
**指标：**
	可用性（Availability） = 正常运行时间 / 总时间
**手段**：
	集群冗余（主从、双机热备、负载均衡）
	故障切换
	健康检查
HP
**指标：**
	响应时间RT
	吞吐量TPS/QPS
**手段：**
	缓存（本地缓存、分布式缓存redis）
	异步化、批处理
	代码、sql优化
	高性能框架
HC
**指标**：
	并发用户数、请求数
**手段**：
	负载均衡（nginx、LVS）
	分布式框架（微服务）
	消息队列削峰（kfka、rabbitmq）
	数据库分表
HR
**手段**：
	事务机制（ACID）
	多副本存储（主从、raft、paxos）
	数据校验与备份
HS：
	无状态服务设计（Stateless Service）
	水平扩展（Scale Out）
	微服务拆分（Microservices）
	容器化与自动伸缩（Docker + Kubernetes）
