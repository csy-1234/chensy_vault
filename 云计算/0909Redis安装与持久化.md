---
date: "20250909"
docx:
  - redis初始.docx
  - redis初持久化.docx
实验: 已做
---
[redis初始.docx](附件/缓存/1-redis初识.docx)
[redis持久化.docx](附件/缓存/2-redis持久化.docx)
# redis安装

## 定位

>Redis 是一个 **内存数据库，用于热点数据的快速增删改查和复杂内存操作**，持久化只是附加的防丢数据手段，而不是核心职责。

## 概念

![[Pasted image 20250909091722.png]]
总结：数据库分为关系型和非关系型

![[Pasted image 20250909092127.png]]
reids是一个内存、可持久化、数据类型丰富的数据库

![[Pasted image 20250909092537.png]]
redis数据类型丰富、可持久化，相对于memcached

配置文件+基础命令
![[6f6d7f48bfd9c89b8da2b1f604f2d4ac.jpg]]
![[58e8dc5a667fff88bd2d6039b67118df.jpg]]
## 安装实验
使用版本：8.2.0
稳定版本6.2 LTS 和 7.2
目的：安装redis
机器：一台vm
效果：redis数据库成功安装，可以连接


![[547aee0145fee42c3c3d3244eac2fadf.jpg]]
![[8bb08d16050739d4d4ab849b12b9211f.jpg]]
# redis持久化
## 概念
### 上课日志
![[Pasted image 20250909100225.png]]
总结：redis有持久化功能，有两种持久化方式:rdb、aof
>“RDB” 就是 “Redis Database”的缩写，表示**快照式持久化**。
>“AOF” 全称是 **Append Only File**，表示**只追加日志文件**，记录每条写操作

![[Pasted image 20250909102032.png]]

![[Pasted image 20250909102209.png]]
总结：rdb效率高、体积小，有丢失的风险
		aof无丢失风险、重写机制，体积大，效率略低
### 整理笔记
#### **持久化定位**
>持久化只是“备份”，不是主要功能
>
>- **RDB / AOF** 只是 **防止断电丢数据**。
  >  
>- Redis 的主目标是 **快速访问和处理数据**，不是长期海量存储。


#### 持久化和日志的区别

| 方面     | 持久化                 | 日志                   |
| ------ | ------------------- | -------------------- |
| 核心目的   | 内存数据复制到磁盘；数据安全，防丢数据 | 记录操作或事件              |
| 记录内容   | Redis 内存数据快照或写操作    | 系统事件或写命令（AOF 属于日志形式） |
| 能否恢复数据 | 可以                  | 一般不能（AOF 除外）         |
| 例子     | RDB、AOF             | system.log、AOF       |
- **RDB** → 纯持久化，记录内存快照，恢复内存数据  
- **AOF** → 持久化 + 日志，记录写操作，可恢复内存数据，同时是操作日志  
- **系统日志** → 日志，记录操作或事件，不能恢复内存数据

#### 默认持久化策略
>redis两种持久化默认都不开启
所以如果你希望启用持久化，就必须手动修改配置文件：
>
`# 开启 RDB 持久化，例如： save 900 1 save 300 10 save 60 10000  # 开启 AOF 持久化 appendonly yes`
>
也就是说，Redis 默认启动后**完全在内存中运行**，关闭持久化。服务器重启后，内存数据会丢失，除非手动配置持久化。
## 持久化实验
机器：一台vm
效果：产生.rdb快照，用于持久化数据

### RDB持久化

![[237546f8b575ea52f74f3da17241af01.jpg]]
### AOF持久化
![[ebebccba97ab8854f76367f0183a38ab.jpg]]





# 扩展
## Redis AOF 重写完整流程

1. **触发重写**
    
    - Redis 检测到 AOF 文件大小满足阈值（`auto-aof-rewrite-min-size` + `auto-aof-rewrite-percentage`）
        
    - 启动 **AOF 重写**
        
2. **创建临时文件**
    
    - Redis 在临时文件 `temp-rewrite.aof` 中写入当前数据库的 **最简命令集合**（去掉冗余，只保留最终状态）
        
3. **重写期间的写入操作**
    
    - 新增写入命令 **原封不动地追加**到临时文件中（不进行简化）
        
    - 保证在重写期间客户端的写操作不会丢失
        
4. **完成重写**
    
    - 临时文件 `temp-rewrite.aof` 包含：
        
        - 当前数据库的最简快照
            
        - 重写期间新增的写入命令
            
    - Redis **替换旧的 AOF 文件**：
        
        - 删除原来的 AOF
            
        - 临时文件重命名为新的正式 AOF 文件
            
5. **下一轮写入与重写**
    
    - 新的 AOF 文件大小成为 **新的基准**
        
    - 后续写入继续记录到 AOF
        
    - 达到下一次触发条件 → 重复上述流程
        

---

### 核心理解

- **AOF 的主要目的是保证数据持久性**
    
- **重写的目的是压缩文件、保留最终数据状态，同时保留重写期间的增量写操作**
    
- **写操作**一般都直接记录到正式 AOF 文件
    
- **重写**只是在后台生成一个精简的新文件，替换旧文件
    
- 这个机制保证 **数据不丢失 + 文件尽量小 + 写入性能稳定**
完全正确，你理解得非常精准！可以把它总结为一句话：

> **重写期间 = Redis 读取旧 AOF、生成最简命令写入临时文件的时间，同时期间的新写入命令也会原封不动地记录到临时文件，保证数据完整。**

再拆开理解：

1. **读取旧 AOF → 生成最简命令**
    
    - 这个过程会把数据库的最终状态压缩成最小的写入命令集合
        
    - 写入临时文件 `temp-rewrite.aof`
        
2. **重写期间的客户端写入**
    
    - 新来的写操作不会丢失
        
    - Redis 会把它们追加到临时文件末尾
        
    - **这些新增命令不会经过简化**
        
3. **重写完成**
    
    - 临时文件包含：
        
        - 最简数据库状态命令
            
        - 重写期间新增的命令
            
    - 替换旧的 AOF 文件 → 成为新的正式 AOF
        

这样做的好处：

- 数据不丢失
    
- AOF 文件更小
    
- 保证写入性能稳定