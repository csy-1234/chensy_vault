---
date: "10250917"
docx:
  - kafka集群部署.docx
实验: 已做
---
[kafka集群部署.docx](附件/企业应用/kafka集群部署.docx)

# 提问

###### ==kafka是什么？==

Apache Kafka 是一个分布式流处理平台

---


 流处理（Stream Processing）
流式数据，Kafka 可以 **实时接收和处理**
生产者不停发送消息 → Kafka 存储并分发 → 消费者实时消费
典型场景：
	网站点击流统计
    日志收集与告警
    实时交易或监控数据处理

分布式（Distributed）
- **核心**：Kafka 集群由多个 Broker 组成，每个 Broker 可以存储 Topic 的 Partition

> - “流处理”强调实时处理不断产生的数据
>     
> - “分布式”强调 Broker 的分布与副本机制

==kafka的存储功能的作用？==

**Kafka 的存储功能是“核心基础”，而不是可选项。**  
它确实能做“流式处理”，但那是在**以磁盘为底层存储**的前提下完成的，而不是“纯内存转发”。

==kafka在企业里做为什么？==

企业最常用 Kafka 的功能是：
- **消息队列 / 消息中间件（解耦 + 异步）**
- **削峰填谷（高并发保护）**
- **日志 / 埋点采集管道**
- **流式计算的消息输入**

这些功能用的是 **Kafka 的同一套核心接口和机制（==Producer、Consumer、Topic、Partition==）**，只是 **场景不同、配置侧重点不同**。

###### ==kafka的单机模式和集群模式的区别？==

- **副本机制**：单机模式没有 Partition 副本，所以无法容忍 Broker 宕机。
    
- **集群管理**：单机模式无需 ZooKeeper，集群模式依赖 ZooKeeper（或 KRaft）进行 Leader 选举和元数据管理。
    
- **高可用和扩展性**：单机模式不具备；集群模式具备。

###### ==kafka与数据库的关系？==

Kafka 是以日志为中心的分布式存储系统，它既能存储数据，也能传递数据，但它不是用来做复杂查询的传统数据库。

###### ==broker数量和副本因子数量关系？==

**Broker 数量 ≥ 副本因子（replication factor）**

换句话说：

- 如果你有 3 个 broker，副本因子最大只能是 3。
    
- 如果你想设置副本因子为 3，必须至少有 3 个 broker。
    
- 副本因子不一定要等于 broker 数量，可以小于，但不能大于。
    

✅ 举例：

|Broker 数量|可用副本因子 RF|
|---|---|
|2|1 或 2|
|3|1、2 或 3|
|5|1~5|

这样设计是为了保证每个分区的副本都可以放到不同的 broker 上，避免单点故障。

###### ==为什么kafka集群最少三个？==

| Broker 数量 | 优点                          | 缺点                   |
| --------- | --------------------------- | -------------------- |
| 1         | 简单、便宜                       | 无高可用，挂掉数据全丢          |
| 2         | 可以做副本                       | 仅能容忍 1 个挂掉，多数派问题导致脑裂 |
| 3（推荐最少）   | 可容忍 1 个挂掉，Leader 选举安全，多数派保证 | 成本比 1、2 高一点          |

###### ==kafka的多数派原则？==

**写操作的多数派原则（ISR）**

- Kafka 维护一个 **ISR（In-Sync Replica，同步副本集合）**，表示与 Leader 数据同步的副本集合。
    
- 当 Producer 写入数据时，Leader 会等待 **ISR 中的大多数副本完成写入**（可配置 `acks` 参数）后，才返回写入成功。
    
    - `acks=all`：要求 ISR 中的所有副本确认写入。
        
    - `acks=1`：只要 Leader 写入成功即可返回。
---
选举多数派原则：
1. **先判断 ISR 内存活副本数量是否满足多数派**
    
    - Kafka 会检查 ISR（In-Sync Replica）中存活的副本数量，必须 **>=多数派（多数副本数量）** 才能进行 Leader 选举。
        
    - 这个多数派数值通常是 `(ISR.size / 2) + 1`。
        
2. **投票选出新的 Leader**
    
    - ISR 内存活的副本会进行投票，选出一个新的 Leader（通常选最先同步的副本或者按照顺序策略）。
        
    - 如果没有任何副本获得多数票，则此次选举失败。
        
3. **循环重试**
    
    - 当选举失败时，Kafka 会 **循环判断存活数是否满足多数派，然后再次尝试投票**，直到选出新的 Leader 或者等待更多副本恢复。
        

简单来说：**判断存活数 >= 多数派 → 投票 → 未选出则循环**，和 ZooKeeper 的 Leader 选举逻辑非常类似。


###### ==关于脑裂？==

- 假设 Partition 副本数 = 3 → 原始 ISR = {B1, B2, B3}
    
- quorum = ⌈3/2⌉ = 2
    

当 B3 被隔离：

- Kafka 会把 B3 从 ISR 中移除 → ISR = {B1, B2}
    
- **quorum 并没有重新计算成 1**，还是按照 Partition 副本数 3 计算：quorum = 2
    
- 为什么？因为 **quorum 永远是基于 Partition 的副本数，不是 ISR 的当前长度**
    

---


- 即使 ISR = {B1, B2}，Leader 选举依然要求至少 **2 个副本存活**
    
- B3 这一边（单独隔离）只有 1 个副本 → 不满足 quorum → **不能选 Leader**
    
- 因此不会产生脑裂
    

---


- **ISR 是动态的**，用于判断哪些副本可以作为 Leader
    
- **quorum 是固定的**，基于 Partition 的副本总数
    
- 网络分区时，只要某一侧副本数量 < quorum → 不能选 Leader → 避免脑裂

###### ==kafka、zookeeper、jdk之间的关系？==

| 项目        | 编写语言         | 依赖  | 是否必须 JDK | 脚本依赖                                              |
| --------- | ------------ | --- | -------- | ------------------------------------------------- |
| Kafka     | Java + Scala | JVM | 是        | kafka-server-start.sh、kafka-console-producer.sh 等 |
| Zookeeper | Java         | JVM | 是        | zkServer.sh、zkCli.sh 等                            |
所以，无论 Kafka 还是 Zookeeper，**必须先安装 JDK**，才能运行它们的脚本和服务

###### ==zookeeper是什么？==

ZooKeeper 是一个开源的**分布式协调服务**

分布式：指的是它管理的对象是分布式系统的节点

协调服务：指 ZooKeeper 提供统一的管理和同步功能，让这些分布式节点能够保持一致性、互相通信和协调操作。


ZooKeeper 本身可以单机运行，也可以部署成分布式集群（通常是 3、5 个节点）来提供高可用性

###### ==zookeeper架构？==

 ZooKeeper 架构

1. **单机模式**
    
    - 只有一个节点，能正常运行，但存在单点故障。
        
2. **集群模式 (Ensemble)**
    
    - 至少 3 个节点，且推荐奇数个（3、5、7…）。
        
    - 节点角色分为/工作原理：
        
        - **Leader**
            
            - 处理所有写请求
                
            - 广播变更，协调数据一致性
                
            - 在选举中当选为 Leader 后才生效
                
        - **Follower**
            
            - 处理读请求
                
            - 复制 Leader 的数据
                
            - **参与选举**（既投票也可能成为候选 Leader）
                
        - **Observer**
            
            - 处理读请求
                
            - 复制 Leader 的数据
                
            - **不参与选举**（既不投票，也不能成为 Leader）
                
            - 主要用来扩展读性能，避免影响写一致性
                

 多数派原则 (Quorum)

- **Leader 当选 & 写操作提交** 都需要 **多数派同意**。
    
- 多数派 = `⌊(N/2)⌋ + 1`，其中 N 只计算 **Leader + Follower 节点数**。
    
- **Observer 不算在多数派里**，因为它不投票、不参与选举。
    

多数派计算：

- 如果集群是 5 台（1 Leader + 4 Follower），多数派是 `⌊5/2⌋ + 1 = 3`。
    
- 如果集群是 5 台（1 Leader + 3 Follower + 1 Observer），多数派仍是 3（不算 Observer）。

- **存活数 ≥ 多数派** → 集群可用（会有合法 Leader 提供服务）。
    
- **存活数 < 多数派** → 集群整体停掉（即使旧 Leader 还活着）。

---
选举多数派：

- **目的**：确定新的 Leader，避免脑裂。
    
- **过程**：
    
    1. 每个 Follower 节点都会投票给自己认为最新的候选 Leader。
        
    2. **候选节点必须获得多数派投票**（超过 `N/2` 个投票）才能当选为 Leader。
        
    3. 如果没有候选节点得到多数派票数，则 **选举失败**，集群暂时没有 Leader。
        
- **总结**：这里多数派是“投票的多数派”，不是存活节点的比较，而是统计投票结果是否达到多数派票数

ookeeper 的 Leader 选举是**有顺序的两步**：

1. **存活节点数检查**：先判断当前存活的节点数量是否 ≥ 集群初始化时的多数派数。如果不满足，多数派原则已经无法达成，选举不会开始。
    
2. **实际投票**：在存活节点数满足条件后，节点开始投票，只有获得超过半数票的节点才能当选 Leader。如果平票，会进行下一轮投票，直到出现超过半数票的节点。

这两步严格按照顺序执行，保证选出的 Leader 一定是安全且不会造成脑裂

---
写操作多数派：
- **目的**：保证写入的数据不会丢失，一致性安全。
    
- **过程**：
    
    1. 客户端写请求发送到 Leader。
        
    2. Leader 写入自己的事务日志，然后 **向所有 Follower 广播写操作**。
        
    3. **只要超过多数派（Leader + 足够多的 Follower）确认写入成功**，Leader 才算写操作成功并返回客户端。
        
    4. 如果未达到多数派确认，写操作阻塞或失败。
        
- **总结**：这里多数派是“写入确认的多数派”，保证数据安全。

###### ==生产环境使用单机模式还是集群模式？==

- **单机模式**仅适合测试或开发环境。
    
- **生产环境**几乎都是集群模式，以降低单点故障风险，提高高可用性和扩展性。

==如何确定属于同一个kafaka集群？==：

\# 唯一标识当前 broker
broker.id=1

\# 所属的 Zookeeper 集群（所有 broker 必须一致）
zookeeper.connect=192.168.10.21:2181,192.168.10.22:2181,192.168.10.23:2181

**在基于 Zookeeper 的 Kafka 集群中：**

- 所有 broker 必须连接到同一个 Zookeeper 集群（相同地址+端口）
    
- 每个 broker 有自己唯一的 `broker.id`
    
- Kafka 的 `cluster.id` 存储在 Zookeeper 中，由此确认“属于同一个集群”。
# 实验

三台机器
![[Pasted image 20251014204427.png]]
![[ae8eb62a6aff26bea77f21defd6ddbe9.jpg]]
效果：
![[Pasted image 20251014211317.png]]