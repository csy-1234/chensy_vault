
# 修改主机名

### 1. 临时修改（重启后失效）

`hostname 新主机名`

立即生效，但系统重启后会恢复。

---

### 2. 永久修改（推荐）

不同系统方法稍微不同：

#### **1.基于 systemd 的系统**

`hostnamectl set-hostname 新主机名`

然后退出再登录终端即可看到新主机名。

---

#### 2.**修改配置文件（通用方法）**

编辑：

`vim /etc/hostname      # 直接写入新主机名`

同时建议在 `/etc/hosts` 中增加对应记录：

`127.0.0.1`  localhost
`127.0.0.1`   myserver`

---

### 3. 验证

`hostname hostnamectl status`

---

# ftp

配置过程
（1）服务端配置
```
# 安装 
vsftpd yum install -y vsftpd  
# 编辑配置文件 
vim /etc/vsftpd/vsftpd.conf 
# 常见修改： 
anonymous_enable=NO local_enable=YES 
write_enable=YES 
chroot_local_user=YES  
# 启动服务 systemctl enable --now vsftpd
```


（2）创建用户与目录
```
useradd ftpuser echo "123456" | passwd --stdin ftpuser mkdir -p /home/ftpuser/upload 
chown ftpuser:ftpuser /home/ftpuser/upload
```


（3）客户端使用
```
ftp 192.168.80.10 
# 登录后：
 ftp> ls 
 ftp> put test.txt 
 ftp> get config.yaml
```


### 1. 匿名模式（anonymous）

- **任何人都可以访问**：对外只需要输入用户名 `anonymous` 或 `ftp`，密码随便填（很多服务器直接忽略密码）。
    
- **运行身份**：
    
    - 不是“临时创建用户”，而是 **FTP服务预先配置好的一个系统用户**（通常是 `ftp` 用户，有的系统是 `nobody` 或 `ftpuser`）。
        
    - 当外部有人以匿名方式登录时，FTP服务会让这些连接“映射”为这个固定的系统用户。
        
    - 所以无论多少匿名用户在访问，**操作系统层面看到的都是同一个 `ftp` 用户在读文件**。
        
- **默认权限**：只能访问 `/var/ftp/` 之类的共享目录，通常只能下载，不能上传或改动。
    

> 🔑 理解关键：匿名用户不是“登录时临时创建”的，而是服务安装时就有的一个特殊系统账号，FTP守护进程把匿名访问映射到这个账号下运行。

---

### 2. 本地模式（local user）

- **用户来源**：就是系统里现有的本地 Linux 用户（/etc/passwd 中定义的）。
    
- **使用方式**：
    
    1. 管理员在 FTP 服务器上用 `useradd` 或其他方式创建账号，例如 `ftpuser1`，并设置密码。
        
    2. 每个本地用户有自己的家目录，比如 `/home/ftpuser1`。
        
    3. FTP 配置文件（如 `/etc/vsftpd/vsftpd.conf`）里启用 `local_enable=YES`。
        
    4. 客户端连接时，输入 `ftpuser1` 和对应密码，就能进入 `/home/ftpuser1`，按该用户在系统里的权限来读写文件。
        
- **权限**：取决于系统用户身份，可能有读、写、上传权限。
    

---

✅ **简要对比：**

- 匿名模式：公共账号 → 映射为系统里的 `ftp` 用户，任何人都能登录，权限统一。
    
- 本地模式：专属账号 → 必须先创建用户，每人单独的家目录，权限更精细。
    

---
# nfs


配置过程：

 NFS 配置（基于 Linux）

（1）服务端配置
```
`# 安装 NFS 服务
 yum install -y nfs-utils 
# 创建共享目录
 mkdir -p /data/nfs 
 # 编辑配置文件
  vim /etc/exports 
 # 内容：
  /data/nfs 192.168.80.0/24(rw,sync,no_root_squash)  
 # 启动并设置开机自启 
 systemctl enable --now nfs-server     
 # 刷新配置
exportfs -r
```
 2）客户端挂载
```
yum install -y nfs-utils  
# 查看共享目录 showmount -e 192.168.80.10 
 # 挂载到本地 mount -t nfs 192.168.80.10:/data/nfs /mnt
 # 永久挂载（可选） echo "192.168.80.10:/data/nfs /mnt nfs defaults 0 0" >> /etc/fstab

```



- **NFS 守护进程运行用户** → `root`
    
- **NFS 客户端匿名访问映射用户** → `nfsnobody`（yum 安装 `nfs-utils` 时创建）
---
**nfs-utils** 包含了 NFS 的服务端和客户端工具。

- **服务端组件**：
    
    - 提供 `nfsd` 服务（NFS 守护进程），用来真正导出共享目录。
        
    - 配置文件：`/etc/exports`，决定哪些目录可以被共享，哪些客户端能访问。
        
    - 常用命令：`exportfs`（管理导出目录）。
        
- **客户端组件**：
    
    - 提供挂载工具，让客户端可以通过 `mount -t nfs` 挂载远程共享目录。
        
    - 例如：
        
        `mount -t nfs 192.168.1.10:/data /mnt/nfs`
        

所以只要安装 `nfs-utils`，一台机器既能当 **NFS 服务器**（配置 `/etc/exports` 并启动服务），也能当 **NFS 客户端**（直接挂载别人共享的目录）。

---
- 默认情况下：
    
    - 客户端 root → **nfsnobody**（因为 root_squash）
        
    - 客户端普通用户 → **不映射**，直接按 UID/GID 判断权限

    >客户端普通用户 → 不映射，直接按 UID/GID 判断权限”的意思
>- NFS 服务端在判断访问权限时，会读取客户端传来的 UID/GID（即远程 Linux 用户 ID）。
>- 然后根据服务器文件系统权限表（文件所有者 UID/GID + 权限位）进行判断。
>- **不进行映射**，就是 **直接把客户端用户视为真实的 UID/GID 去匹配服务器文件权限**>
        
- 如果你在 `/etc/exports` 中加上 `all_squash`：
    
    - **所有客户端用户** 都映射成 nfsnobody
        
- 如果去掉 `root_squash`：
    
    - 客户端 root 会保持 root 权限 → 风险很大

# nfs和ftp
**NFS = 像本地磁盘一样使用远程目录（文件系统级共享）**

> **FTP = 通过上传/下载命令传文件（应用层传输协议）**


|场景|用哪个|
|---|---|
|集群共享文件目录（如 K8s PV）|✅ **NFS**|
|临时传文件、外网传输|✅ **FTP / SFTP**|
|需要高安全、传输加密|✅ **SFTP（基于 SSH）**|
|简单共享配置、数据目录|✅ **NFS（内网）**|
# profile和profile.d
### 加载机制

1. 登录 shell 会先加载 `/etc/profile`
    
2. `/etc/profile` 内通常有一段代码：
    

`for i in /etc/profile.d/*.sh; do     if [ -r "$i" ]; then         . "$i"     fi done`

- 会遍历 `/etc/profile.d/` 下所有可读的 `.sh` 文件并执行
    
- 这样 `/etc/profile.d/` 下的脚本就会被加载到 shell 环境中
这样做的目的是：
- **集中管理**：不同软件或服务可以各自放一个脚本，不用修改 `/etc/profile`
    
- **系统全局生效**：所有用户登录 shell 都会加载这些脚本
    
- **便于扩展和卸载**：删除某个软件对应的脚本即可，不影响其他设置
# shell脚本执行方式
### `source` 或 `.` 加载脚本

`source /etc/profile.d/java.sh . /etc/profile.d/java.sh`

- **是否需要执行权限？** ❌ 不需要

### 直接执行脚本

./java.sh   # 或 sh java.sh`

- **是否需要执行权限？** ✅ 需要（`./java.sh` 方式需要）
    
- **原因**：直接执行会启动子 shell，新进程执行该脚本，shell 需要知道它有权限执行这个文件。
    
- **权限要求**：加上 `x`（可执行），例如：

| 调用方式                  | 文件需要 `x` 权限吗？ |
| --------------------- | ------------- |
| `./myscript.sh`       | 是             |
| `bash/sh myscript.sh` | 否             |
| `source myscript.sh`  | 否             |