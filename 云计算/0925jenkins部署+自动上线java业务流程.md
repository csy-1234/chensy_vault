---
date: "20250925"
docx:
  - 3-jenkins部署.docx
  - 4-自动上线java业务流程.docx
实验: 已做
---
[3-jenkins部署.docx](附件/CI-CD流程/3-jenkins部署.docx)
[4-自动上线java业务流程.docx](附件/CI-CD流程/4-自动上线java业务流程.docx)

# jenkins部署

**==Jenkins简介**==

==**持续集成、交付、部署**==

==**安装Jenkins==**

>rpm方式
>安装jdk---下载依赖---yum安装---修改启动用户+启动jenkins
>浏览器访问：ip：8080
# 自动上线java业务流程

实验实现效果：
![[Pasted image 20251016144853.png]]
# 补充
==jenkins可以做什么？==
 **1️⃣ 代码管理与持续集成（CI）**

- 自动拉取最新代码
    
- 自动合并没有冲突的分支
    
- 发现冲突时生成报告、阻止破坏主干
    
- 自动构建与编译（生成二进制/可执行文件）
    
- 打包（将编译产物 + 依赖整合成可部署包）
    
- 自动化测试
    
    - 单元测试、集成测试、冒烟测试
        
    - 代码质量检查（如 SonarQube、Checkstyle）
        

---

**2️⃣ 持续交付/部署（CD）**

- 自动化环境部署
    
- 支持多环境自动部署（测试/预生产/生产）
    
- 部署方式灵活：
    
    - Shell 脚本
        
    - 插件（Deploy、SSH、Docker 等）
        
    - 容器镜像
        
- 可视化部署流程（通过插件展示执行状态）
    

---

 **3️⃣ 流水线（Pipeline）**

- Pipeline 即代码（Jenkinsfile）
    
- 流水线代码存入 Git 仓库，多人协作维护
    
- 流水线权限控制（不同角色可限制编辑或触发）
    

---

 **4️⃣ 架构与任务管理**

- 分布式构建：
    
    - Master 管理流水线和任务
        
    - Slave 执行构建、测试、部署
        
- 定时任务 / 触发机制：
    
    - 定时执行（Cron）
        
    - 事件触发（代码提交、HTTP 请求、其他流水线完成）
        

---

✅ **总结一句话**：  
Jenkins 是一个高度可扩展的自动化服务器，通过 CI/CD 流程、Pipeline、分布式构建和插件生态，实现从代码提交到部署全流程自动化，同时支持权限控制、可视化管理和定时/事件触发。

==持续化部署两条路径？==
可以把它拆成两条典型路径来看：

---

**路径一：CI → Code Review → 持续交付（CD）**

1. **持续集成（CI）**：自动构建、测试，确认代码质量。
    
2. **人工代码审查（Code Review/MR 审批）**：决定是否合并主干。
    
3. **持续交付（Continuous Delivery）**：主干更新后，自动打包、部署到测试/预发布环境，生成可上线版本。
    
4. **人工审批 / 手动触发**：是否上线到生产，由人来决定。  
    👉 这是 **大多数企业常用的流程**，因为生产环境风险高。
    

---

**路径二：CI → Code Review → 持续部署（CD）**

1. **持续集成（CI）**：同上。
    
2. **人工代码审查（Code Review/MR 审批）**：同上。
    
3. **持续部署（Continuous Deployment）**：通过测试后 **直接自动上线生产**，没有人工审批。  
    👉 这是 **自动化程度最高** 的模式，常见于互联网公司或对回滚有非常强保证的场景（比如灰度发布 + 自动回滚）。
    

---

🔑 区别在于：

- **持续交付**：上线生产这一步，需要 **人决定**。
    
- **持续部署**：上线生产这一步，**全自动**。

==两种CD的的区别？==
 持续交付（Continuous Delivery）

- 自动化程度：中等
    
- 流程：  
    CI ✅ → Code Review ✅ → 打包/部署到测试环境 ✅ → **生产部署需要人工审批/手动触发**
    
- 场景：
    
    - 金融、政企、大型传统行业
        
    - 生产环境风险大，必须人工把关
        

---

🔹 持续部署（Continuous Deployment）

- 自动化程度：最高
    
- 流程：  
    CI ✅ → Code Review ✅ → 打包/部署到测试环境 ✅ → **自动上线生产**（无人工审批）
    
- 场景：
    
    - 互联网公司（高频迭代）
        
    - 有灰度发布、蓝绿部署、自动回滚机制，能快速兜底
        

---

✅ 所以你可以理解为：

- 两者都是在 **CI + Code Review 合并主干之后** 才会进行。
    
- 区别就是 **生产环境上线是否要人参与**。

==代码流转过程？==
**CI/CD 流程中代码如何流动、每个阶段的产物到底是什么**”，我帮你梳理一个非常清晰的全链路，按 **代码处理 → 产物 → 流程动作 → 人工点** 来说明。

---

**1️⃣ 持续集成（CI）阶段**

**输入**：开发者提交的源代码（Java 源码、配置文件等）

**处理步骤**：

1. Jenkins 拉取分支代码（feature 分支）
    
2. 临时合并到主干副本（CI 环境中）
    
3. 自动构建（编译源码 → class/jar 文件）
    
4. 自动化单元测试、代码质量检查
    

**产出物**：

- 编译好的 **二进制文件**（.class 文件、.jar 包）
    
- **测试报告**（单元测试结果、覆盖率）
    
- **代码质量报告**（静态分析结果）
    

**人工环节**：

- **代码审查（Code Review / Merge Request 审批）**
    
    - 决定是否将 feature 分支合并到主干
        

💡 重点：CI 的 jar 包是**中间产物**，主要用于验证代码是否健康，不一定直接上线生产。

---

 **2️⃣ 持续交付（CD - Delivery）阶段**

**输入**：CI 阶段合并后的主干代码

**处理步骤**：

1. 自动构建/打包（生成 **可部署的制品**：Jar/WAR/Docker 镜像）
    
2. 自动部署到 **测试环境 / 预发布环境**
    
3. 自动化验收测试（接口测试、集成测试、UI 测试等）
    

**产出物**：

- **生产就绪的制品**（artifact：Jar/WAR/Docker 镜像）
    
- **测试/预发布环境实例**（可运行系统，用于验证功能）
    
- 测试报告、验收结果
    

**人工环节**：

- **人工审批或手动触发 Jenkins 部署生产**
    

💡 重点：CD-Delivery 阶段的 jar/镜像和 CI 阶段的 jar 是 **同一代码编译产物，但经过验收测试验证**，具备随时部署到生产的条件。

---

 **3️⃣ 持续部署（CD - Deployment）阶段**

**输入**：持续交付阶段验证通过的制品

**处理步骤**：

1. 自动部署到生产环境
    
2. 可选灰度发布 / 蓝绿部署 / 自动回滚机制
    

**产出物**：

- **生产环境运行系统**（用户可访问）
    
- 监控和告警数据
    

**人工环节**：

- 理论上 **不需要人工审批**（全链路自动化）
    

💡 重点：持续部署和持续交付区别主要在 **生产部署是否有人参与**。