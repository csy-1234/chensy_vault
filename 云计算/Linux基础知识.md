# Linux发行版

Ubuntu
# Linux常见软件安装方式

四种
## 包管理工具
### 自动
#### 步骤
```
yum install
apt install
```
- **优点**：
    - 简单方便，一条命令就搞定
    - 自动处理依赖
    - 后期更新升级方便（安全补丁及时）
- **缺点**：
    - 版本可能不是最新（取决于发行版仓库）
        
    - 配置路径可能和官方文档不完全一致（被发行版维护者修改过）
### 半自动|手动
#### 步骤
```
rpm
dpkg
```
- **优点**：
    
    - 可以获得官方提供的更高版本（比系统仓库新）
    - 安装速度快
- **缺点**：
    - 可能遇到依赖问题（需要手动解决 `依赖地狱`）
    - 升级维护不如包管理工具方便
## 源码编译安装
#### 步骤
C/C++源码包专用
```
tar zxvf mysql.tar.gz 
cd mysql 
./configure make make install
```

Java / Python / Ruby / Go / Rust 源码包→ 使用各自语言的构建工具
    
- 所以看到源码包，第一步要看它是什么语言写的，再选择安装方式

- **优点**：
    - 自由度最高，可以自己定制编译选项（优化性能、裁剪功能）
    - 能获得最新版本
- **缺点**：
    - 编译过程复杂，耗时长
    - 出问题难排查
    - 升级维护麻烦（需要重新编译）
c源码包需要的工具：

|工具|作用|
|---|---|
|**gcc**|C 编译器，负责把 `.c` 文件编译成目标文件 `.o`|
|**g++**|C++ 编译器，负责编译 `.cpp` 文件|
|**make**|根据 Makefile 自动化执行编译步骤|
|**autoconf / automake**|生成 `configure` 脚本，检查系统环境和依赖|
|**libtool**|帮助生成共享库 `.so` 或静态库 `.a`|
|**pkg-config**|检查系统中已安装的库和路径|
|**开发库 / 头文件**|例如 `zlib-devel`, `openssl-devel`，提供库和头文件供编译器使用|
安装工具链：
```
yum groupinstall "Development Tools"   #提供 C/C++ 开发和编译环境,其他语言源码包编译/运行工具不在这个组里，需要对应语言的运行环境或编译器
yum install zlib-devel openssl-devel jemalloc-devel -y #库和头文件单独安装（缺少了再安装），保证编译能成功链接
```
## 二进制压缩包

官方预编译包
#### 步骤

- **二进制压缩包**解压就能用，不需要编译，也不依赖 `yum/apt/rpm`。
    
- **优点**：
    
    - 免编译，安装速度快
    - 路径清晰，便于多版本并存
- **缺点**：
    - 需要手动管理依赖
    - 不会自动更新（要自己下载新版本替换）
## 容器方式

Docker 安装
####  步骤
    
    `docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0`
    
- **优点**：
    
    - 部署极快（秒级）
        
    - 隔离性好，不影响宿主机环境
        
    - 多版本共存非常方便
        
- **缺点**：
    
    - 学习成本（需要了解 Docker）
        
    - 性能稍低于直接安装（但差距很小）

## 对比
| 方式        | 难度  | 维护方便 | 最新版本 | 性能优化 | 使用场景      |
| --------- | --- | ---- | ---- | ---- | --------- |
| 包管理工具     | ⭐   | ⭐⭐⭐⭐ | 中    | 中    | 常规安装      |
| RPM/DEB 包 | ⭐⭐  | ⭐⭐   | 高    | 中    | 新版本需求     |
| 源码编译安装    | ⭐⭐⭐ | ⭐    | 最高   | 最高   | 性能极致/特殊需求 |
| 二进制压缩包    | ⭐⭐  | ⭐⭐   | 高    | 中    | 多版本并存     |
| Docker 安装 | ⭐⭐  | ⭐⭐⭐⭐ | 高    | 中    | 快速部署/测试环境 |
| 自建仓库打包    | ⭐⭐⭐ | ⭐⭐⭐  | 高    | 高    | 企业级大规模管理  |
- 如果是**个人学习 / 普通部署** → **包管理工具**（最省心）
    
- 如果是**想体验最新版本** → 用 **官方二进制包 / Docker**
    
- 如果是**企业生产环境、要极致性能** → **源码编译 / 自建仓库**

### 启动方式
- **YUM/DNF 安装** → 一定能直接用 `systemctl` 管理。
    
- **RPM 安装** → 大概率能用，但要看 RPM 包里有没有附带 service 文件。
    
- **二进制压缩包 / 源码编译** → 默认没有 service，需要手动写,或者手动命令启动。

# 不同平台的安装包选择

## 源码包、二进制包、系统包的依赖
### **源码包（Source Code）**

- **最顶层、最通用**
    
- **不依赖操作系统、CPU 架构或 glibc 版本**
    
- 使用前必须 自己编译，生成可执行文件
    
- 优点：跨平台、灵活、可优化
    
- 缺点：安装复杂、需要编译工具链
    

---

### **预编译二进制包（Binary）**

- **依赖 OS / 架构 / glibc 等系统环境**
    
- 下载前必须确认你的系统符合要求
    
- 优点：解压即可用，无需编译
    
- 缺点：不通用，可能和系统 glibc/库不兼容
    

---

### **系统包（RPM / DEB）**

- **最依赖系统环境**
    
- 必须匹配系统发行版和 CPU 架构（CentOS/RHEL/Ubuntu/Debian）
    
- 优点：安装方便，可自动管理依赖、升级和卸载
    
- 缺点：只能在指定系统上用
    

---

💡 **一句话总结**：

`源码包 → 通用但需编译 二进制包 → 系统/架构受限，直接用 系统包 → 系统依赖最强，方便管理`

## 各种安装方式的自由度
### **源码包**

- **自由度最高**：可以优化编译参数、指定安装路径
    
- **便捷性最低**：需要自己 `configure → make → make install`
    
- **封装最少**：安装过程完全自己掌控，系统不会帮你管理依赖
    

---

###  **预编译二进制包**

- **自由度中等**：不能改变编译参数，但可以选择解压路径
    
- **便捷性较高**：解压即可用，无需自己编译
    
- **封装更多**：官方已经编译好了，依赖 glibc 等系统库
    

---

###  **系统包（RPM / DEB）**

- **自由度最低**：安装路径、依赖库、文件位置都固定
    
- **便捷性最高**：`yum install` 或 `apt install` 就能完成安装、升级、卸载
    
- **封装最多**：系统包管理器帮你处理依赖和更新，几乎不用自己动手
    

---

💡 **总结一句话**：

> 越方便使用的软件包，越封装，用户可控性越低；源码包最灵活但麻烦，系统包最便捷但受限多。


## 安装包选择

### 区分方式
源码、二进制、rpm

| 类型  | 扩展名                   | 文件名提示                      | 使用方式                              |
| --- | --------------------- | -------------------------- | --------------------------------- |
| 源码  | .tar.gz/.tar.bz2/.zip | 带 src 或 version，不带 OS/arch | ./configure → make → make install |
| 二进制 | .tar.gz/.zip          | 带 OS/arch/glibc 等          | 解压 → 配置环境变量 → 直接使用                |
| 系统包 | .rpm/.deb             | 带系统/arch版本                 | rpm/yum/dpkg/apt install          |
### 区分平台
#### Linux

32 位 Linux（x86）
-i586.rpm或tar.gz

64位  （x86_64 = amd64 = x64）
-x64.rpm或tar.gz

ARM 服务器 / 树莓派
64位
-aarch64.rpm或-aarch64.tar.gz
32位
-arm32-vfp-hflt.tar.gz

#### windows
64 位
-x64.exe

32 位
-i586.exe

#### macOS
-macosx-x64.dmg

# 安装目录

各种方式的安装文件目录分布

| 安装方式      | 默认路径                                     | 手动指定                | 备注                                                         |
| --------- | ---------------------------------------- | ------------------- | ---------------------------------------------------------- |
| YUM / RPM | 系统标准路径 `/usr/bin /etc /var/lib /var/log` | 不可随意                | 方便 ，使用`yum` / `rpm` + `systemctl`管理                        |
| 二进制包      | 无默认路径，用户解压到哪就是哪                          | 解压到指定目录             | 自成体系；手动管理                                                  |
| 源码编译      | `/usr/local`                             | `--prefix=/opt/软件名` | 默认不指定 --prefix，不成体系，管理麻烦；指定 --prefix，所有内容集中在指定目录，自成体系；手动管理 |

源码编译推荐使用--prefix指定安装目录
>- **默认安装** → 文件分散到 `/usr/local` 的各个子目录，不成体系
>    
>- **手动指定 `--prefix`** → 所有内容集中在一个目录下，类似二进制包解压效果，更好管理
  >  
>- **实际使用**：大多数情况下，源码安装推荐用 `--prefix` 指定目录


指定--prefix目录和二进制解压目录一般使用：
`/opt/软件名`
既方便管理，又不污染系统其他目录

# 源码安装的过程解析
1. **`make` 阶段**
    
    - 只负责编译源代码 → 生成目标文件 (`.o`) → 链接成二进制文件（比如 `nginx`、`mysqld`、`redis-server` 等）。
        
    - 这些二进制文件通常还停留在源码树里（比如 `objs/nginx`、`src/redis-server`）。
        
2. **`make install` 阶段**
    
    - 会读取 `Makefile` 里的 `install` 规则，这些规则一般是 `configure` 脚本根据 `--prefix=...` 选项生成的。
        
    - 除了把二进制文件复制到指定目录（比如 `--prefix=/usr/local/nginx`），还会：
        
        - **创建目录结构**（`bin/`, `conf/`, `lib/`, `include/`, `logs/`, `data/` 等）；
            
        - **复制配置文件**（例如 `nginx.conf.default`、`my.cnf.sample`）；
            
        - **复制文档或示例**；
            
        - **安装头文件/库文件**（方便开发者调用）。
            

---

🔎 举个例子：

- **Redis 的 `make install`**
    
    - 很简单，只是把 `redis-server`, `redis-cli` 等几个可执行文件复制到 `/usr/local/bin/`（或 `--prefix/bin/`），基本不创建目录。
        
- **Nginx 的 `make install`**
    
    - 除了安装 `nginx` 可执行文件，还会在 `--prefix` 下创建：
        
        - `conf/nginx.conf`（默认配置文件），
            
        - `logs/`（日志目录），
            
        - `html/`（默认网页），
            
        - `sbin/nginx`（可执行程序）。
            

所以你说的对：  
👉 **`make install` 不仅安装二进制，还负责创建目录和放置配置文件，具体做什么取决于 `Makefile` 的 install 部分定义**
# Linux内核

## **Linux 和 C 的关系**

- Linux 内核是 **用 C 写的**（部分汇编）。
    
- 所以 **Linux 的生态天然围绕 C 语言和 glibc**。
    
- 这就是为什么 glibc 对 Linux 那么重要：它几乎是所有语言访问内核的“中间人”。

## clibc

- **glibc 的本质：C 标准库的实现**
    
- **直接使用者：C/C++ 程序**
    
- **间接使用者：Java、Python、Go 等语言的运行时**（它们本身是 C/C++ 写的，最终还要靠 glibc 调用内核）
    
- **原因：Linux 底层就是 C 写的，glibc 是 Linux 用户态访问内核的主要接口**。


# 协议
- **协议 = 通信规范**
    
- **实现协议的软件 = 能收、能懂、能回该协议的请求**
    
- “某软件实现了某协议” ≈ “该软件能正确处理该协议的请求与响应”
# 文件、目录权限
Linux 默认权限体系和 umask 的标准行为：

umask默认是022
目录权限就是777-022=755
文件权限就是666-022=644

也就是说
**目录**都有的权限是r-x,**都可以进入查看的**，只有**属主才能创建和删除文件目录**；

**文件**都是有r--，**都可以看内容**，只有**属主才能修改**文件内容，默认**没有执行权限**

# 编程语言
## 分类
- **脚本语言**：Python、PHP、JavaScript
    
    - 解释执行、开发效率高、灵活，但高性能场景需要优化
        
- **编译/静态语言**：Java、C/C++、C#、Go、Rust
    
    - 编译执行、类型安全、性能高，适合大型企业级系统或底层服务

分类1，执行方式：

|类型|语言示例|特点|
|---|---|---|
|**编译型语言**|C、C++、Java（编译成字节码）|先编译成二进制或字节码，再执行；性能高|
|**解释型语言（脚本语言）**|Python、PHP、JavaScript、Ruby|直接解释执行，开发效率高，性能相对低|
|**半编译/虚拟机语言**|Java、C#|编译成中间字节码，在虚拟机（JVM/.NET CLR）上运行；兼顾跨平台与性能|

分类2， 按编程范式分类：

|范式|语言示例|特点|
|---|---|---|
|**面向对象**|Java、C++、C#、Python|使用类和对象建模，强调封装、继承、多态|
|**函数式**|Haskell、Scala、F#、JavaScript（部分）、Python（部分）|强调不可变、函数是第一类对象|
|**过程式/命令式**|C、Pascal、Python|以过程/函数调用为核心，按步骤执行命令|
|**逻辑式**|Prolog|通过规则和逻辑推理解决问题|
|**声明式**|SQL、HTML（标记语言）|描述“做什么”，而不是“怎么做”|

分类3，按用途分类

|用途|语言示例|特点|
|---|---|---|
|**系统/底层开发**|C、C++、Rust|高性能、直接操作内存，适合操作系统、驱动、游戏引擎|
|**企业级/后端开发**|Java、C#、Python、Go|支持大型项目、数据库操作、分布式系统|
|**Web 开发**|JavaScript、Python、PHP、Ruby|前后端开发、快速迭代、社区成熟|
|**数据科学/AI**|Python、R、Julia|强大的科学计算库、数据处理能力|
|**脚本/自动化**|Python、Shell、Perl、JavaScript|自动化任务、快速开发、运维脚本|

语言历史脉络总结

- **1970s-80s**：C 诞生 → 系统编程、操作系统
    
- **1980s**：C++ → 面向对象、大型系统
    
- **1990s**：Java、Python、PHP、JavaScript → 企业级 Web、脚本语言崛起
    
- **2000s**：C# → Windows 企业软件，.NET 生态
    
- **2010s**：Go、Rust → 云原生、高性能安全系统
## 用途

**主流编程语言的用途大全**：
## **🔹 系统/底层开发**

- **C**：操作系统（Linux、Windows 内核）、驱动、嵌入式
    
- **C++**：游戏引擎（Unreal、Unity 部分）、桌面软件（Qt）、高性能库（数据库引擎、浏览器内核）
    
- **Rust**：安全替代 C/C++，WebAssembly、嵌入式、系统安全组件
    

---

## **🔹 企业级 / 后端开发**

- **Java**：企业级应用（银行、保险、电商）、Spring 全家桶、Android
    
- **C# (.NET)**：Windows 应用、企业内部系统、游戏（Unity 脚本）
    
- **Go (Golang)**：高并发后端、云原生、Kubernetes、微服务
    

---

## **🔹 Web 开发**

- **JavaScript**：前端交互（React、Vue）、全栈（Node.js）
    
- **TypeScript**：大型前端项目（Angular、React）、更安全的 JS
    
- **PHP**：网站、CMS（WordPress、Drupal）、中小企业 Web
    
- **Ruby**：Web 框架 Ruby on Rails，快速构建 Web 产品
    
- **Python**：Web 框架（Django、Flask）、API 后端
    

---

## **🔹 移动开发**

- **Java / Kotlin**：Android
    
- **Swift / Objective-C**：iOS
    
- **Flutter (Dart)**：跨平台（Android+iOS）
    
- **React Native (JS)**：跨平台移动应用
    

---

## **🔹 数据科学 / AI / 机器学习**

- **Python**：NumPy、Pandas、TensorFlow、PyTorch
    
- **R**：统计分析、可视化
    
- **Julia**：科学计算、高性能数值分析
    
- **MATLAB**：科研、工程、数学建模
    

---

## **🔹 游戏开发**

- **C++**：大型 3D 游戏引擎（Unreal、CryEngine）
    
- **C#**：Unity 游戏引擎脚本
    
- **Lua**：游戏脚本（魔兽世界、Roblox）
    
- **Python**：小游戏、原型验证
    

---

## **🔹 脚本 / 自动化 / 运维**

- **Python**：自动化脚本、爬虫、DevOps
    
- **Shell (Bash)**：Linux 运维脚本
    
- **Perl**：文本处理、旧系统维护
    
- **PowerShell**：Windows 系统运维
    

---

## **🔹 数据库 & 查询语言**

- **SQL**：数据库查询（MySQL、PostgreSQL、Oracle）
    
- **PL/SQL**（Oracle）、**T-SQL**（SQL Server）：数据库存储过程
    

---

## **🔹 其他特殊用途**

- **Scala**：大数据（Spark）
    
- **Erlang/Elixir**：电信系统、分布式系统（WhatsApp）
    
- **Haskell**：函数式编程研究、编译器
    
- **COBOL**：银行金融遗留系统
    
- **Fortran**：科学计算（超级计算机）
    

---

💡 **总结规律**

1. **C / C++ / Rust** → 底层 & 高性能
    
2. **Java / C# / Go / Python** → 企业级 & 后端
    
3. **JavaScript / PHP / Ruby** → Web 开发
    
4. **Python / R / Julia** → AI & 数据科学
    
5. **Swift / Kotlin / Dart** → 移动开发
# 企业对软件系统的6高？
常见的“高”

1. **高可靠（High Reliability）**
    
    - 数据不丢失，系统出错能恢复。
    - 强调的是自我恢复和应对故障的能力
        
2. **高可用（High Availability）**
    
    - 系统几乎 7x24 小时可用，停机时间极短。
    - 强调的是不间断的提供服务
        
3. **高并发（High Concurrency）**
    
    - 支撑大量用户同时访问和操作。
        
4. **高性能（High Performance）**
    
    - 系统响应速度快，处理效率高。
        
5. **高扩展性（High Scalability）**
    
    - 随着业务增长，可以方便地横向/纵向扩容。
        
6. **高安全性（High Security）**
    
    - 数据访问安全、权限控制严格、传输加密。
        
7. **高可维护性（High Maintainability）**
    
    - 系统架构清晰，运维、监控、排错方便。
        

---

💡 总结：  
企业对系统的要求，常见的就是 **高可靠、高可用、高并发、高性能、高扩展性、高安全性**，有时候也叫 **“六高”**。

# 基础常识
==基础命令目录真实存储目录==？

新系统里 `/bin` 和 `/sbin` 是软链接，真正的命令都在 `/usr/bin` 和 `/usr/sbin` 
老系统里 `/bin` 和 `/sbin` 仍然是真实目录。

==eval是什么==？

- **第一次展开**（命令行阶段）：`\` 把 `$` 当作普通字符，防止被提前展开
    
- **第二次展开**（eval 内 Bash 再解析）：`\` 已经失效，Bash 去掉它，然后真正展开 `$VAR`
    

可以把 `\` 想象成 **一次性的保护罩**，只作用于第一次展开，让 `$` 保持字面量。第二次展开时，保护罩被移除，变量就可以正常解析。

总结一句话：

> `\` 延迟了 `$` 的展开，只能阻止一次，eval 的再解析让它失效，从而实现动态变量名访问。

==添加环境变量正确写法==？

```
[root@hadoop aaa bbb]# cat /etc/profile.d/java.sh 
#!/bin/bash

# 设置 Java 安装路径
export JAVA_HOME=/usr/java/latest
export JRE_HOME=$JAVA_HOME/jre

# 判断 CLASSPATH 是否已经包含 JAVA_HOME/lib 和 JRE_HOME/lib，避免重复添加
if [[ ":$CLASSPATH:" != *":$JAVA_HOME/lib:"* ]]; then
    export CLASSPATH=${CLASSPATH:+$CLASSPATH:}$JAVA_HOME/lib
fi

if [[ ":$CLASSPATH:" != *":$JRE_HOME/lib:"* ]]; then
    export CLASSPATH=${CLASSPATH:+$CLASSPATH:}$JRE_HOME/lib
fi

# 判断 PATH 是否已经包含 JAVA_HOME/bin 和 JRE_HOME/bin，避免重复添加
if [[ ":$PATH:" != *":$JAVA_HOME/bin:"* ]]; then
    export PATH=$PATH:$JAVA_HOME/bin
fi

if [[ ":$PATH:" != *":$JRE_HOME/bin:"* ]]; then
    export PATH=$PATH:$JRE_HOME/bin
fi

```

# POP3/IMAP/SMTP

### 两种典型场景

1. **网页端 / 官方邮箱 App**
    
    - 协议：**HTTPS**（加密传输）
        
    - 登录方式：**账户 + 登录密码**
        
    - 安全性：高（受厂商全链路控制，支持风控/验证码/二次认证）
        
2. **第三方客户端 / 系统（Outlook、Zabbix、企业应用等）**
    
    - 协议：**POP3 / IMAP / SMTP**（标准开放协议）
        
    - 登录方式：**授权码**（而不是登录密码）
        
    - 安全性：高（授权码泄露风险小、可随时吊销，不影响主密码）
        

---

### 🔑 总结

- **账户+密码** 在 **HTTPS 环境** 是安全的。
    
- **授权码** 在 **POP3/IMAP/SMTP 环境** 是安全的。
    

📌 换句话说：  
邮箱厂商是根据 **不同协议的风险环境** 来选择对应的安全机制，并不是说账户+密码一定不安全，而是 **在 POP3/IMAP/SMTP 这种开放协议里风险更大，所以换成授权码**。

## 1. **授权码泄露的风险**

- 攻击者能做的事：
    
    - **收邮件**：下载你的收件箱（POP3/IMAP），看到所有邮件内容。
        
    - **发邮件**：冒充你向别人发信（SMTP），可能用于诈骗/钓鱼。
        
- 攻击者不能做的事：
    
    - 改密码、删账号、关二次验证。
        
    - 登录网页版邮箱（需要账户+密码+可能的二次认证）。
        

👉 所以，授权码泄露 = **邮件数据层面的风险**，但不会导致账号完全被接管。

---

## 2. **账户+密码泄露的风险**

- 攻击者能做的事：
    
    - 上面授权码能做的所有事 ✅
        
    - 还能进网页端，改密码、解绑手机、关安全验证 ❌
        
- 结果：**整个账号被彻底接管**，远比授权码泄露严重。
    

---

## 3. **风险对比**

|泄露对象|风险级别|主要后果|
|---|---|---|
|**账户+密码**|🔴 高|账号完全被接管，邮件+设置+安全措施全失控|
|**授权码**|🟠 中|邮件被盗取/冒充发信，但账号可控，可吊销授权码|

---

📌 **结论**：

- 授权码不是绝对安全，它只是把“账号接管风险”降低成“邮件内容泄露风险”。
    
- 如果邮件内容本身很敏感（比如合同、财务、密码重置邮件），那么泄露仍然是严重问题。
    
- 最佳实践是：
    
    1. **尽量只在可信客户端使用授权码**。
        
    2. **定期吊销不用的授权码**。
        
    3. **开启二次验证**（网页端登录时进一步保护）。





# linux指标监控
## **CPU 指标**
top

| 指标             | 含义            | 判断依据                |
| -------------- | ------------- | ------------------- |
| `%us`          | 用户态 CPU 使用率   | 高说明应用程序占用 CPU 多     |
| `%sy`          | 内核态 CPU 使用率   | 高说明系统调用或驱动开销大       |
| `%wa`          | CPU 等待 I/O 时间 | 高说明 CPU 等待磁盘/网络 I/O |
| `%id`          | 空闲 CPU 百分比    | 低说明 CPU 繁忙，可能成为瓶颈   |
| `load average` | 系统平均负载        | 高于 CPU 核心数 → CPU 瓶颈 |
## **内存指标**
free -h

|指标|含义|判断依据|
|---|---|---|
|`free`|空闲内存|过低 → 内存不足|
|`used`|已用内存|高但 swap 小 → 内存紧张|
|`buffers/cache`|缓存/缓冲区|可优化缓存策略|
|`swap used` (`swpd`)|交换区使用|高 → 内存不足，系统频繁换页，性能下降|
## **磁盘 I/O 指标**

iostat -x 1

|指标|含义|判断依据|
|---|---|---|
|`r/s`、`w/s`|每秒读写次数|高 → I/O 繁忙|
|`await`|平均 I/O 等待时间|高 → 磁盘响应慢|
|`%util`|磁盘利用率|接近 100% → 磁盘成为瓶颈|

## **网络指标**

nload网卡实时流量

|指标|含义|判断依据|
|---|---|---|
|带宽占用|网络流量|高 → 网络瓶颈|
|TCP 连接数 / 状态|连接数、SYN/ESTAB|过多 → 应用或网络可能过载|
- 网卡接口的 **平均流量（Avg）** 或 **实时流量（Curr）**
- **网卡瓶颈判断**：
    Avg 流量≈接口理论带宽上限或Curr 流量瞬时接近上限\text{Avg 流量} \approx \text{接口理论带宽上限} \quad \text{或} \quad \text{Curr 流量瞬时接近上限}Avg 流量≈接口理论带宽上限或Curr 流量瞬时接近上限
- **结论**：接近或超过带宽上限 → 可能出现网络瓶颈。

ss -tna | wc -l
TCP 连接数高，是系统瓶颈的一个表现。关键看两个指标：系统总文件描述符是否接近上限（TCP + 文件等资源共用），以及单个进程打开的连接数是否接近其 ulimit 限制。超过任意一个都会影响服务可用性。”


## **系统/进程指标**

| 指标                | 含义          | 判断依据                |
| ----------------- | ----------- | ------------------- |
| `run queue` / `r` | 等待 CPU 的进程数 | 高于 CPU 核心数 → CPU 瓶颈 |
| 高 CPU 进程          | `%CPU`      | 找到消耗 CPU 的进程进行优化    |
| 高内存进程             | `%MEM`      | 找到消耗内存的进程进行优化       |

**判断性能瓶颈主要看 CPU（使用率、负载）、内存（可用、swap）、磁盘 I/O（利用率、等待）、网络（带宽、连接数）、以及关键进程的资源占用**。、


vmstat 1（每秒刷新一次）`r` 列就是 **等待 CPU 执行的进程数**（run queue）
“`run queue` 或 `r` 表示当前等待 CPU 调度的可运行进程数。如果这个数大于 CPU 核心数，就说明 CPU 已经成为瓶颈，可能导致系统响应延迟增加；如果小于或接近 CPU 核心数，则 CPU 负载正常。

## 内存、cpu瓶颈定位

==cpu：==
top
 查看 load average：
 1分钟、5分钟、15分钟平均负载
 如果 load > CPU 核心数 → CPU 瓶颈

排查高cpu进程：
top、ps aux

	top -o %CPU
	ps aux --sort=-%cpu | head -n 10
==内存：==
free -h   # 总体内存、缓存、swap
top -o %MEM
ps aux --sort=-%mem | head -n 10


**判断瓶颈**

- CPU：load average > 核心数 或 r 列长时间 > 核心数
- 内存：swap 使用高，物理内存紧张

**优化处理**
- 重启高消耗进程
- 调整程序配置、优化代码
- 增加硬件资源（CPU/内存）


**优化参数调整**

- 内核参数：`sysctl` 调整 TCP、文件句柄、网络缓冲区等
    
- 服务参数：Nginx、MySQL、Java 服务线程数、连接数、缓存策略等
**资源瓶颈诊断方法**

- 分析 CPU、内存、磁盘、网络指标
- 使用 `top`, `vmstat`, `iostat`, `sar`, `dstat`
- 查找高资源占用进程和异常服务